// Package wsltestutils implements helper functions for frequently needed functionality
// in Windows-Agent and End-to-End tests.
package wsltestutils

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	wsl "github.com/ubuntu/gowsl"
)

const (
	testDistroPrefix = "testDistro_UP4W"
)

// NonRegisteredDistro generates a random distroName and GUID but does not register them.
func NonRegisteredDistro(t *testing.T) (distroName string, GUID string) {
	t.Helper()

	distroName = RandomDistroName(t)

	guid, err := uuid.NewRandom()
	require.NoError(t, err, "Setup: could not generate a GUID for the non-registered distro")

	GUID = fmt.Sprintf("{%s}", guid.String())
	return distroName, GUID
}

// RandomDistroName generates a distroName that is not registered guaranteed not to collide with the reserved distro IDs (such as Ubuntu-XX.YY or Ubuntu-Preview).
func RandomDistroName(t *testing.T) (name string) {
	t.Helper()

	p := regexp.MustCompile(`[^a-zA-Z0-9_\-\.]+`)
	name = p.ReplaceAllString(t.Name(), "_")

	//nolint:gosec // No need to be cryptographically secure
	return fmt.Sprintf("%s_%s_%d", testDistroPrefix, name, rand.Uint64())
}

// DistroState returns the state of the distro as specified by wsl.exe. Possible states:
// - Installing
// - Running
// - Stopped
// - Unregistered.
//
//nolint:revive // The context is better after the testing.T
func DistroState(t *testing.T, ctx context.Context, distroName string) string {
	t.Helper()

	d := wsl.NewDistro(ctx, distroName)
	s, err := d.State()
	require.NoError(t, err) // Error message is explanatory enough
	return s.String()
}

// requireIsTestDistro requires a distroName to match those generated by the testutils.
// It is intended to protect other distros in the machine.
func requireIsTestDistro(t *testing.T, distroName string) {
	t.Helper()

	if !strings.HasPrefix(distroName, testDistroPrefix) {
		require.Fail(t, "testutils can only be used with test distros", "Requested distro: %s", distroName)
	}
}

// RegisterDistroNamed registers a distro and returns its GUID.
//
//nolint:revive // The context is better after the testing.T
func RegisterDistroNamed(t *testing.T, ctx context.Context, distroName string) (GUID string) {
	t.Helper()

	return registerDistro(t, ctx, distroName, true)
}

// RegisterDistro registers a distro and returns its randomly-generated name and its GUID.
//
//nolint:revive // The context is better after the testing.T
func RegisterDistro(t *testing.T, ctx context.Context, realDistro bool) (distroName string, GUID string) {
	t.Helper()

	distroName = RandomDistroName(t)
	guid := registerDistro(t, ctx, distroName, realDistro)
	return distroName, guid
}

// UnregisterDistro unregisters a WSL distro. Errors are ignored.
//
//nolint:revive // The context is better after the testing.T
func UnregisterDistro(t *testing.T, ctx context.Context, distroName string) {
	t.Helper()

	requireIsTestDistro(t, distroName)

	d := wsl.NewDistro(ctx, distroName)
	_ = d.Unregister()
}

// ReregisterDistro unregister, then registers the same distro again.
//
//nolint:revive // The context is better after the testing.T
func ReregisterDistro(t *testing.T, ctx context.Context, distroName string, realDistro bool) (GUID string) {
	t.Helper()

	UnregisterDistro(t, ctx, distroName)
	return registerDistro(t, ctx, distroName, realDistro)
}

// TerminateDistro shuts down that distro in particular.
// Wrapper for `wsl -t distro`.
//
//nolint:revive // The context is better after the testing.T
func TerminateDistro(t *testing.T, ctx context.Context, distroName string) {
	t.Helper()

	requireIsTestDistro(t, distroName)

	d := wsl.NewDistro(ctx, distroName)
	_ = d.Terminate()
}

//nolint:revive // The context is better after the testing.T
func registerDistro(t *testing.T, ctx context.Context, distroName string, realDistro bool) (GUID string) {
	t.Helper()

	if !wsl.MockAvailable() {
		var rootFsPath string
		if realDistro {
			const appx = "UbuntuPreview"
			appxDir := powershellOutputf(t, `(Get-AppxPackage | Where-Object Name -like 'CanonicalGroupLimited.%s').InstallLocation`, appx)
			require.NotEmpty(t, appxDir, "could not find rootfs tarball. Is %s installed?", appx)
			rootFsPath = filepath.Join(appxDir, "install.tar.gz")
		}
		return PowershellImportDistro(t, ctx, distroName, rootFsPath)
	}

	t.Cleanup(func() {
		UnregisterDistro(t, ctx, distroName)
	})

	dir := t.TempDir()
	rootfs := filepath.Join(dir, "empty.tar.gz")
	err := os.WriteFile(rootfs, []byte{}, 0600)
	require.NoError(t, err, "could not write empty fake rootfs")

	d := wsl.NewDistro(ctx, distroName)
	err = d.Register(rootfs)
	require.NoError(t, err) // Error messsage is explanatory enough

	guid, err := d.GUID()
	require.NoError(t, err, "Setup: could not get distro GUID")

	return guid.String()
}
